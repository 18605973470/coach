{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Coach? Motivation Train and evaluate reinforcement learning agents by harnessing the power of multi-core CPU processing to achieve state-of-the-art results. Provide a sandbox for easing the development process of new algorithms through a modular design and an elegant set of APIs. Solution Coach is a python environment which models the interaction between an agent and an environment in a modular way. With Coach, it is possible to model an agent by combining various building blocks, and training the agent on multiple environments. The available environments allow testing the agent in different practical fields such as robotics, autonomous driving, games and more. Coach collects statistics from the training process and supports advanced visualization techniques for debugging the agent being trained. Blog post from the Intel\u00ae AI website can be found here . GitHub repository is here . Design","title":"Home"},{"location":"#what-is-coach","text":"","title":"What is Coach?"},{"location":"#motivation","text":"Train and evaluate reinforcement learning agents by harnessing the power of multi-core CPU processing to achieve state-of-the-art results. Provide a sandbox for easing the development process of new algorithms through a modular design and an elegant set of APIs.","title":"Motivation"},{"location":"#solution","text":"Coach is a python environment which models the interaction between an agent and an environment in a modular way. With Coach, it is possible to model an agent by combining various building blocks, and training the agent on multiple environments. The available environments allow testing the agent in different practical fields such as robotics, autonomous driving, games and more. Coach collects statistics from the training process and supports advanced visualization techniques for debugging the agent being trained. Blog post from the Intel\u00ae AI website can be found here . GitHub repository is here .","title":"Solution"},{"location":"#design","text":"","title":"Design"},{"location":"dashboard/index.html","text":"Reinforcement learning algorithms are neat. That is - when they work. But when they don't, RL algorithms are often quite tricky to debug. Finding the root cause for why things break in RL is rather difficult. Moreover, different RL algorithms shine in some aspects, but then lack on other. Comparing the algorithms faithfully is also a hard task, which requires the right tools. Coach Dashboard is a visualization tool which simplifies the analysis of the training process. Each run of Coach extracts a lot of information from within the algorithm and stores it in the experiment directory. This information is very valuable for debugging, analyzing and comparing different algorithms. But without a good visualization tool, this information can not be utilized. This is where Coach Dashboard takes place. Visualizing Signals Coach Dashboard exposes a convenient user interface for visualizing the training signals. The signals are dynamically updated - during the agent training. Additionaly, it allows selecting a subset of the available signals, and then overlaying them on top of each other. Holding the CTRL key, while selecting signals, will allow visualizing more than one signal. Signals can be visualized, using either of the Y-axes, in order to visualize signals with different scales. To move a signal to the second Y-axis, select it and press the 'Toggle Second Axis' button. Tracking Statistics When running parallel algorithms, such as A3C, it often helps visualizing the learning of all the workers, at the same time. Coach Dashboard allows viewing multiple signals (and even smooth them out, if required) from multiple workers. In addition, it supports viewing the mean and standard deviation of the same signal, across different workers, using Bollinger bands. Displaying Bollinger Bands Displaying All The Workers Comparing Runs Reinforcement learning algorithms are notoriously known as unstable, and suffer from high run-to-run variance. This makes benchmarking and comparing different algorithms even harder. To ease this process, it is common to execute several runs of the same algorithm and average over them. This is easy to do with Coach Dashboard, by centralizing all the experiment directories in a single directory, and then loading them as a single group. Loading several groups of different algorithms then allows comparing the averaged signals, such as the total episode reward. In RL, there are several interesting performance metrics to consider, and this is easy to do by controlling the X-axis units in Coach Dashboard. It is possible to switch between several options such as the total number of steps or the total training time. Comparing Several Algorithms According to the Time Passed Comparing Several Algorithms According to the Number of Episodes Played","title":"Coach Dashboard"},{"location":"dashboard/index.html#visualizing-signals","text":"Coach Dashboard exposes a convenient user interface for visualizing the training signals. The signals are dynamically updated - during the agent training. Additionaly, it allows selecting a subset of the available signals, and then overlaying them on top of each other. Holding the CTRL key, while selecting signals, will allow visualizing more than one signal. Signals can be visualized, using either of the Y-axes, in order to visualize signals with different scales. To move a signal to the second Y-axis, select it and press the 'Toggle Second Axis' button.","title":"Visualizing Signals"},{"location":"dashboard/index.html#tracking-statistics","text":"When running parallel algorithms, such as A3C, it often helps visualizing the learning of all the workers, at the same time. Coach Dashboard allows viewing multiple signals (and even smooth them out, if required) from multiple workers. In addition, it supports viewing the mean and standard deviation of the same signal, across different workers, using Bollinger bands. Displaying Bollinger Bands Displaying All The Workers","title":"Tracking Statistics"},{"location":"dashboard/index.html#comparing-runs","text":"Reinforcement learning algorithms are notoriously known as unstable, and suffer from high run-to-run variance. This makes benchmarking and comparing different algorithms even harder. To ease this process, it is common to execute several runs of the same algorithm and average over them. This is easy to do with Coach Dashboard, by centralizing all the experiment directories in a single directory, and then loading them as a single group. Loading several groups of different algorithms then allows comparing the averaged signals, such as the total episode reward. In RL, there are several interesting performance metrics to consider, and this is easy to do by controlling the X-axis units in Coach Dashboard. It is possible to switch between several options such as the total number of steps or the total training time. Comparing Several Algorithms According to the Time Passed Comparing Several Algorithms According to the Number of Episodes Played","title":"Comparing Runs"},{"location":"usage/index.html","text":"Coach Usage Training an Agent Single-threaded Algorithms This is the most common case. Just choose a preset using the -p flag and press enter. Example: python coach.py -p CartPole_DQN Multi-threaded Algorithms Multi-threaded algorithms are very common this days. They typically achieve the best results, and scale gracefully with the number of threads. In Coach, running such algorithms is done by selecting a suitable preset, and choosing the number of threads to run using the -n flag. Example: python coach.py -p CartPole_A3C -n 8 Evaluating an Agent There are several options for evaluating an agent during the training: For multi-threaded runs, an evaluation agent will constantly run in the background and evaluate the model during the training. For single-threaded runs, it is possible to define an evaluation period through the preset. This will run several episodes of evaluation once in a while. Additionally, it is possible to save checkpoints of the agents networks and then run only in evaluation mode. Saving checkpoints can be done by specifying the number of seconds between storing checkpoints using the -s flag. The checkpoints will be saved into the experiment directory. Loading a model for evaluation can be done by specifying the -crd flag with the experiment directory, and the --evaluate flag to disable training. Example: python coach.py -p CartPole_DQN -s 60 python coach.py -p CartPole_DQN --evaluate -crd CHECKPOINT_RESTORE_DIR Playing with the Environment as a Human Interacting with the environment as a human can be useful for understanding its difficulties and for collecting data for imitation learning. In Coach, this can be easily done by selecting a preset that defines the environment to use, and specifying the --play flag. When the environment is loaded, the available keyboard buttons will be printed to the screen. Pressing the escape key when finished will end the simulation and store the replay buffer in the experiment dir. Example: python coach.py -p Breakout_DQN --play Learning Through Imitation Learning Learning through imitation of human behavior is a nice way to speedup the learning. In Coach, this can be done in two steps - Create a dataset of demonstrations by playing with the environment as a human. After this step, a pickle of the replay buffer containing your game play will be stored in the experiment directory. The path to this replay buffer will be printed to the screen. To do so, you should select an environment type and level through the command line, and specify the --play flag. Example: python coach.py -et Doom -lvl Basic --play Next, use an imitation learning preset and set the replay buffer path accordingly. The path can be set either from the command line or from the preset itself. Example: python coach.py -p Doom_Basic_BC -cp='agent.load_memory_from_file_path=\\\"<experiment dir>/replay_buffer.p\\\"' Visualizations Rendering the Environment Rendering the environment can be done by using the -r flag. When working with multi-threaded algorithms, the rendered image will be representing the game play of the evaluation worker. When working with single-threaded algorithms, the rendered image will be representing the single worker which can be either training or evaluating. Keep in mind that rendering the environment in single-threaded algorithms may slow the training to some extent. When playing with the environment using the --play flag, the environment will be rendered automatically without the need for specifying the -r flag. Example: python coach.py -p Breakout_DQN -r Dumping GIFs Coach allows storing GIFs of the agent game play. To dump GIF files, use the -dg flag. The files are dumped after every evaluation episode, and are saved into the experiment directory, under a gifs sub-directory. Example: python coach.py -p Breakout_A3C -n 4 -dg Switching between deep learning frameworks Coach uses TensorFlow as its main backend framework, but it also supports neon for some of the algorithms. By default, TensorFlow will be used. It is possible to switch to neon using the -f flag. Example: python coach.py -p Doom_Basic_DQN -f neon Additional Flags There are several convenient flags which are important to know about. Here we will list most of the flags, but these can be updated from time to time. The most up to date description can be found by using the -h flag. Flag Type Description -p PRESET , `--preset PRESET string Name of a preset to run (as configured in presets.py) -l , --list flag List all available presets -e EXPERIMENT_NAME , --experiment_name EXPERIMENT_NAME string Experiment name to be used to store the results. -r , --render flag Render environment -f FRAMEWORK , --framework FRAMEWORK string Neural network framework. Available values: tensorflow, neon -n NUM_WORKERS , --num_workers NUM_WORKERS int Number of workers for multi-process based agents, e.g. A3C --play flag Play as a human by controlling the game with the keyboard. This option will save a replay buffer with the game play. --evaluate flag Run evaluation only. This is a convenient way to disable training in order to evaluate an existing checkpoint. -v , --verbose flag Don't suppress TensorFlow debug prints. -s SAVE_MODEL_SEC , --save_model_sec SAVE_MODEL_SEC int Time in seconds between saving checkpoints of the model. -crd CHECKPOINT_RESTORE_DIR , --checkpoint_restore_dir CHECKPOINT_RESTORE_DIR string Path to a folder containing a checkpoint to restore the model from. -dg , --dump_gifs flag Enable the gif saving functionality. -at AGENT_TYPE , --agent_type AGENT_TYPE string Choose an agent type class to override on top of the selected preset. If no preset is defined, a preset can be set from the command-line by combining settings which are set by using --agent_type , --experiment_type , --environemnt_type -et ENVIRONMENT_TYPE , --environment_type ENVIRONMENT_TYPE string Choose an environment type class to override on top of the selected preset. If no preset is defined, a preset can be set from the command-line by combining settings which are set by using --agent_type , --experiment_type , --environemnt_type -ept EXPLORATION_POLICY_TYPE , --exploration_policy_type EXPLORATION_POLICY_TYPE string Choose an exploration policy type class to override on top of the selected preset.If no preset is defined, a preset can be set from the command-line by combining settings which are set by using --agent_type , --experiment_type , --environemnt_type -lvl LEVEL , --level LEVEL string Choose the level that will be played in the environment that was selected. This value will override the level parameter in the environment class. -cp CUSTOM_PARAMETER , --custom_parameter CUSTOM_PARAMETER string Semicolon separated parameters used to override specific parameters on top of the selected preset (or on top of the command-line assembled one). Whenever a parameter value is a string, it should be inputted as '\\\"string\\\"' . For ex.: \"visualization.render=False; num_training_iterations=500; optimizer='rmsprop'\"","title":"Usage"},{"location":"usage/index.html#coach-usage","text":"","title":"Coach Usage"},{"location":"usage/index.html#training-an-agent","text":"","title":"Training an Agent"},{"location":"usage/index.html#single-threaded-algorithms","text":"This is the most common case. Just choose a preset using the -p flag and press enter. Example: python coach.py -p CartPole_DQN","title":"Single-threaded Algorithms"},{"location":"usage/index.html#multi-threaded-algorithms","text":"Multi-threaded algorithms are very common this days. They typically achieve the best results, and scale gracefully with the number of threads. In Coach, running such algorithms is done by selecting a suitable preset, and choosing the number of threads to run using the -n flag. Example: python coach.py -p CartPole_A3C -n 8","title":"Multi-threaded Algorithms"},{"location":"usage/index.html#evaluating-an-agent","text":"There are several options for evaluating an agent during the training: For multi-threaded runs, an evaluation agent will constantly run in the background and evaluate the model during the training. For single-threaded runs, it is possible to define an evaluation period through the preset. This will run several episodes of evaluation once in a while. Additionally, it is possible to save checkpoints of the agents networks and then run only in evaluation mode. Saving checkpoints can be done by specifying the number of seconds between storing checkpoints using the -s flag. The checkpoints will be saved into the experiment directory. Loading a model for evaluation can be done by specifying the -crd flag with the experiment directory, and the --evaluate flag to disable training. Example: python coach.py -p CartPole_DQN -s 60 python coach.py -p CartPole_DQN --evaluate -crd CHECKPOINT_RESTORE_DIR","title":"Evaluating an Agent"},{"location":"usage/index.html#playing-with-the-environment-as-a-human","text":"Interacting with the environment as a human can be useful for understanding its difficulties and for collecting data for imitation learning. In Coach, this can be easily done by selecting a preset that defines the environment to use, and specifying the --play flag. When the environment is loaded, the available keyboard buttons will be printed to the screen. Pressing the escape key when finished will end the simulation and store the replay buffer in the experiment dir. Example: python coach.py -p Breakout_DQN --play","title":"Playing with the Environment as a Human"},{"location":"usage/index.html#learning-through-imitation-learning","text":"Learning through imitation of human behavior is a nice way to speedup the learning. In Coach, this can be done in two steps - Create a dataset of demonstrations by playing with the environment as a human. After this step, a pickle of the replay buffer containing your game play will be stored in the experiment directory. The path to this replay buffer will be printed to the screen. To do so, you should select an environment type and level through the command line, and specify the --play flag. Example: python coach.py -et Doom -lvl Basic --play Next, use an imitation learning preset and set the replay buffer path accordingly. The path can be set either from the command line or from the preset itself. Example: python coach.py -p Doom_Basic_BC -cp='agent.load_memory_from_file_path=\\\"<experiment dir>/replay_buffer.p\\\"'","title":"Learning Through Imitation Learning"},{"location":"usage/index.html#visualizations","text":"","title":"Visualizations"},{"location":"usage/index.html#rendering-the-environment","text":"Rendering the environment can be done by using the -r flag. When working with multi-threaded algorithms, the rendered image will be representing the game play of the evaluation worker. When working with single-threaded algorithms, the rendered image will be representing the single worker which can be either training or evaluating. Keep in mind that rendering the environment in single-threaded algorithms may slow the training to some extent. When playing with the environment using the --play flag, the environment will be rendered automatically without the need for specifying the -r flag. Example: python coach.py -p Breakout_DQN -r","title":"Rendering the Environment"},{"location":"usage/index.html#dumping-gifs","text":"Coach allows storing GIFs of the agent game play. To dump GIF files, use the -dg flag. The files are dumped after every evaluation episode, and are saved into the experiment directory, under a gifs sub-directory. Example: python coach.py -p Breakout_A3C -n 4 -dg","title":"Dumping GIFs"},{"location":"usage/index.html#switching-between-deep-learning-frameworks","text":"Coach uses TensorFlow as its main backend framework, but it also supports neon for some of the algorithms. By default, TensorFlow will be used. It is possible to switch to neon using the -f flag. Example: python coach.py -p Doom_Basic_DQN -f neon","title":"Switching between deep learning frameworks"},{"location":"usage/index.html#additional-flags","text":"There are several convenient flags which are important to know about. Here we will list most of the flags, but these can be updated from time to time. The most up to date description can be found by using the -h flag. Flag Type Description -p PRESET , `--preset PRESET string Name of a preset to run (as configured in presets.py) -l , --list flag List all available presets -e EXPERIMENT_NAME , --experiment_name EXPERIMENT_NAME string Experiment name to be used to store the results. -r , --render flag Render environment -f FRAMEWORK , --framework FRAMEWORK string Neural network framework. Available values: tensorflow, neon -n NUM_WORKERS , --num_workers NUM_WORKERS int Number of workers for multi-process based agents, e.g. A3C --play flag Play as a human by controlling the game with the keyboard. This option will save a replay buffer with the game play. --evaluate flag Run evaluation only. This is a convenient way to disable training in order to evaluate an existing checkpoint. -v , --verbose flag Don't suppress TensorFlow debug prints. -s SAVE_MODEL_SEC , --save_model_sec SAVE_MODEL_SEC int Time in seconds between saving checkpoints of the model. -crd CHECKPOINT_RESTORE_DIR , --checkpoint_restore_dir CHECKPOINT_RESTORE_DIR string Path to a folder containing a checkpoint to restore the model from. -dg , --dump_gifs flag Enable the gif saving functionality. -at AGENT_TYPE , --agent_type AGENT_TYPE string Choose an agent type class to override on top of the selected preset. If no preset is defined, a preset can be set from the command-line by combining settings which are set by using --agent_type , --experiment_type , --environemnt_type -et ENVIRONMENT_TYPE , --environment_type ENVIRONMENT_TYPE string Choose an environment type class to override on top of the selected preset. If no preset is defined, a preset can be set from the command-line by combining settings which are set by using --agent_type , --experiment_type , --environemnt_type -ept EXPLORATION_POLICY_TYPE , --exploration_policy_type EXPLORATION_POLICY_TYPE string Choose an exploration policy type class to override on top of the selected preset.If no preset is defined, a preset can be set from the command-line by combining settings which are set by using --agent_type , --experiment_type , --environemnt_type -lvl LEVEL , --level LEVEL string Choose the level that will be played in the environment that was selected. This value will override the level parameter in the environment class. -cp CUSTOM_PARAMETER , --custom_parameter CUSTOM_PARAMETER string Semicolon separated parameters used to override specific parameters on top of the selected preset (or on top of the command-line assembled one). Whenever a parameter value is a string, it should be inputted as '\\\"string\\\"' . For ex.: \"visualization.render=False; num_training_iterations=500; optimizer='rmsprop'\"","title":"Additional Flags"},{"location":"algorithms/imitation/bc/index.html","text":"Behavioral Cloning Actions space: Discrete|Continuous Network Structure Algorithm Description Training the network The replay buffer contains the expert demonstrations for the task. These demonstrations are given as state, action tuples, and with no reward. The training goal is to reduce the difference between the actions predicted by the network and the actions taken by the expert for each state. Sample a batch of transitions from the replay buffer. Use the current states as input to the network, and the expert actions as the targets of the network. The loss function for the network is MSE, and therefore we use the Q head to minimize this loss.","title":"Behavioral Cloning"},{"location":"algorithms/imitation/bc/index.html#behavioral-cloning","text":"Actions space: Discrete|Continuous","title":"Behavioral Cloning"},{"location":"algorithms/imitation/bc/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/imitation/bc/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/imitation/bc/index.html#training-the-network","text":"The replay buffer contains the expert demonstrations for the task. These demonstrations are given as state, action tuples, and with no reward. The training goal is to reduce the difference between the actions predicted by the network and the actions taken by the expert for each state. Sample a batch of transitions from the replay buffer. Use the current states as input to the network, and the expert actions as the targets of the network. The loss function for the network is MSE, and therefore we use the Q head to minimize this loss.","title":"Training the network"},{"location":"algorithms/other/dfp/index.html","text":"Direct Future Prediction Actions space: Discrete References: Learning to Act by Predicting the Future Network Structure Algorithm Description Choosing an action The current states (observations and measurements) and the corresponding goal vector are passed as an input to the network. The output of the network is the predicted future measurements for time-steps t+1,t+2,t+4,t+8,t+16 and t+32 for each possible action. For each action, the measurements of each predicted time-step are multiplied by the goal vector, and the result is a single vector of future values for each action. Then, a weighted sum of the future values of each action is calculated, and the result is a single value for each action. The action values are passed to the exploration policy to decide on the action to use. Training the network Given a batch of transitions, run them through the network to get the current predictions of the future measurements per action, and set them as the initial targets for training the network. For each transition (s_t,a_t,r_t,s_{t+1} ) in the batch, the target of the network for the action that was taken, is the actual measurements that were seen in time-steps t+1,t+2,t+4,t+8,t+16 and t+32 . For the actions that were not taken, the targets are the current values.","title":"Direct Future Prediction"},{"location":"algorithms/other/dfp/index.html#direct-future-prediction","text":"Actions space: Discrete References: Learning to Act by Predicting the Future","title":"Direct Future Prediction"},{"location":"algorithms/other/dfp/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/other/dfp/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/other/dfp/index.html#choosing-an-action","text":"The current states (observations and measurements) and the corresponding goal vector are passed as an input to the network. The output of the network is the predicted future measurements for time-steps t+1,t+2,t+4,t+8,t+16 and t+32 for each possible action. For each action, the measurements of each predicted time-step are multiplied by the goal vector, and the result is a single vector of future values for each action. Then, a weighted sum of the future values of each action is calculated, and the result is a single value for each action. The action values are passed to the exploration policy to decide on the action to use.","title":"Choosing an action"},{"location":"algorithms/other/dfp/index.html#training-the-network","text":"Given a batch of transitions, run them through the network to get the current predictions of the future measurements per action, and set them as the initial targets for training the network. For each transition (s_t,a_t,r_t,s_{t+1} ) in the batch, the target of the network for the action that was taken, is the actual measurements that were seen in time-steps t+1,t+2,t+4,t+8,t+16 and t+32 . For the actions that were not taken, the targets are the current values.","title":"Training the network"},{"location":"algorithms/policy_optimization/ac/index.html","text":"Actor-Critic Actions space: Discrete|Continuous References: Asynchronous Methods for Deep Reinforcement Learning Network Structure Algorithm Description Choosing an action - Discrete actions The policy network is used in order to predict action probabilites. While training, a sample is taken from a categorical distribution assigned with these probabilities. When testing, the action with the highest probability is used. Training the network A batch of T_{max} transitions is used, and the advantages are calculated upon it. Advantages can be calculated by either of the following methods (configured by the selected preset) - A_VALUE - Estimating advantage directly: A(s_t, a_t) = \\underbrace{\\sum_{i=t}^{i=t + k - 1} \\gamma^{i-t}r_i +\\gamma^{k} V(s_{t+k})}_{Q(s_t, a_t)} - V(s_t) where k is T_{max} - State\\_Index for each state in the batch. GAE - By following the Generalized Advantage Estimation paper. The advantages are then used in order to accumulate gradients according to L = -\\mathop{\\mathbb{E}} [log (\\pi) \\cdot A]","title":"Actor-Critic"},{"location":"algorithms/policy_optimization/ac/index.html#actor-critic","text":"Actions space: Discrete|Continuous References: Asynchronous Methods for Deep Reinforcement Learning","title":"Actor-Critic"},{"location":"algorithms/policy_optimization/ac/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/policy_optimization/ac/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/policy_optimization/ac/index.html#choosing-an-action-discrete-actions","text":"The policy network is used in order to predict action probabilites. While training, a sample is taken from a categorical distribution assigned with these probabilities. When testing, the action with the highest probability is used.","title":"Choosing an action - Discrete actions"},{"location":"algorithms/policy_optimization/ac/index.html#training-the-network","text":"A batch of T_{max} transitions is used, and the advantages are calculated upon it. Advantages can be calculated by either of the following methods (configured by the selected preset) - A_VALUE - Estimating advantage directly: A(s_t, a_t) = \\underbrace{\\sum_{i=t}^{i=t + k - 1} \\gamma^{i-t}r_i +\\gamma^{k} V(s_{t+k})}_{Q(s_t, a_t)} - V(s_t) where k is T_{max} - State\\_Index for each state in the batch. GAE - By following the Generalized Advantage Estimation paper. The advantages are then used in order to accumulate gradients according to L = -\\mathop{\\mathbb{E}} [log (\\pi) \\cdot A]","title":"Training the network"},{"location":"algorithms/policy_optimization/cppo/index.html","text":"Clipped Proximal Policy Optimization Actions space: Discrete|Continuous References: Proximal Policy Optimization Algorithms Network Structure Algorithm Description Choosing an action - Continuous action Same as in PPO. Training the network Very similar to PPO, with several small (but very simplifying) changes: Train both the value and policy networks, simultaneously, by defining a single loss function, which is the sum of each of the networks loss functions. Then, back propagate gradients only once from this unified loss function. The unified network's optimizer is set to Adam (instead of L-BFGS for the value network as in PPO). Value targets are now also calculated based on the GAE advantages. In this method, the V values are predicted from the critic network, and then added to the GAE based advantages, in order to get a Q value for each action. Now, since our critic network is predicting a V value for each state, setting the Q calculated action-values as a target, will on average serve as a V state-value target. Instead of adapting the penalizing KL divergence coefficient used in PPO, the likelihood ratio r_t(\\theta) =\\frac{\\pi_{\\theta}(a|s)}{\\pi_{\\theta_{old}}(a|s)} is clipped, to achieve a similar effect. This is done by defining the policy's loss function to be the minimum between the standard surrogate loss and an epsilon clipped surrogate loss: L^{CLIP}(\\theta)=E_{t}[min(r_t(\\theta)\\cdot \\hat{A}_t, clip(r_t(\\theta), 1-\\epsilon, 1+\\epsilon) \\cdot \\hat{A}_t)]","title":"Clipped Proximal Policy Optimization"},{"location":"algorithms/policy_optimization/cppo/index.html#clipped-proximal-policy-optimization","text":"Actions space: Discrete|Continuous References: Proximal Policy Optimization Algorithms","title":"Clipped Proximal Policy Optimization"},{"location":"algorithms/policy_optimization/cppo/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/policy_optimization/cppo/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/policy_optimization/cppo/index.html#choosing-an-action-continuous-action","text":"Same as in PPO.","title":"Choosing an action - Continuous action"},{"location":"algorithms/policy_optimization/cppo/index.html#training-the-network","text":"Very similar to PPO, with several small (but very simplifying) changes: Train both the value and policy networks, simultaneously, by defining a single loss function, which is the sum of each of the networks loss functions. Then, back propagate gradients only once from this unified loss function. The unified network's optimizer is set to Adam (instead of L-BFGS for the value network as in PPO). Value targets are now also calculated based on the GAE advantages. In this method, the V values are predicted from the critic network, and then added to the GAE based advantages, in order to get a Q value for each action. Now, since our critic network is predicting a V value for each state, setting the Q calculated action-values as a target, will on average serve as a V state-value target. Instead of adapting the penalizing KL divergence coefficient used in PPO, the likelihood ratio r_t(\\theta) =\\frac{\\pi_{\\theta}(a|s)}{\\pi_{\\theta_{old}}(a|s)} is clipped, to achieve a similar effect. This is done by defining the policy's loss function to be the minimum between the standard surrogate loss and an epsilon clipped surrogate loss: L^{CLIP}(\\theta)=E_{t}[min(r_t(\\theta)\\cdot \\hat{A}_t, clip(r_t(\\theta), 1-\\epsilon, 1+\\epsilon) \\cdot \\hat{A}_t)]","title":"Training the network"},{"location":"algorithms/policy_optimization/ddpg/index.html","text":"Deep Deterministic Policy Gradient Actions space: Continuous References: Continuous control with deep reinforcement learning Network Structure Algorithm Description Choosing an action Pass the current states through the actor network, and get an action mean vector \\mu . While in training phase, use a continuous exploration policy, such as the Ornstein-Uhlenbeck process, to add exploration noise to the action. When testing, use the mean vector \\mu as-is. Training the network Start by sampling a batch of transitions from the experience replay. To train the critic network , use the following targets: y_t=r(s_t,a_t )+\\gamma \\cdot Q(s_{t+1},\\mu(s_{t+1} )) First run the actor target network, using the next states as the inputs, and get \\mu (s_{t+1} ) . Next, run the critic target network using the next states and \\mu (s_{t+1} ) , and use the output to calculate y_t according to the equation above. To train the network, use the current states and actions as the inputs, and y_t as the targets. To train the actor network , use the following equation: \\nabla_{\\theta^\\mu } J \\approx E_{s_t \\tilde{} \\rho^\\beta } [\\nabla_a Q(s,a)|_{s=s_t,a=\\mu (s_t ) } \\cdot \\nabla_{\\theta^\\mu} \\mu(s)|_{s=s_t} ] Use the actor's online network to get the action mean values using the current states as the inputs. Then, use the critic online network in order to get the gradients of the critic output with respect to the action mean values \\nabla _a Q(s,a)|_{s=s_t,a=\\mu(s_t ) } . Using the chain rule, calculate the gradients of the actor's output, with respect to the actor weights, given \\nabla_a Q(s,a) . Finally, apply those gradients to the actor network. After every training step, do a soft update of the critic and actor target networks' weights from the online networks.","title":"Deep Determinstic Policy Gradients"},{"location":"algorithms/policy_optimization/ddpg/index.html#deep-deterministic-policy-gradient","text":"Actions space: Continuous References: Continuous control with deep reinforcement learning","title":"Deep Deterministic Policy Gradient"},{"location":"algorithms/policy_optimization/ddpg/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/policy_optimization/ddpg/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/policy_optimization/ddpg/index.html#choosing-an-action","text":"Pass the current states through the actor network, and get an action mean vector \\mu . While in training phase, use a continuous exploration policy, such as the Ornstein-Uhlenbeck process, to add exploration noise to the action. When testing, use the mean vector \\mu as-is.","title":"Choosing an action"},{"location":"algorithms/policy_optimization/ddpg/index.html#training-the-network","text":"Start by sampling a batch of transitions from the experience replay. To train the critic network , use the following targets: y_t=r(s_t,a_t )+\\gamma \\cdot Q(s_{t+1},\\mu(s_{t+1} )) First run the actor target network, using the next states as the inputs, and get \\mu (s_{t+1} ) . Next, run the critic target network using the next states and \\mu (s_{t+1} ) , and use the output to calculate y_t according to the equation above. To train the network, use the current states and actions as the inputs, and y_t as the targets. To train the actor network , use the following equation: \\nabla_{\\theta^\\mu } J \\approx E_{s_t \\tilde{} \\rho^\\beta } [\\nabla_a Q(s,a)|_{s=s_t,a=\\mu (s_t ) } \\cdot \\nabla_{\\theta^\\mu} \\mu(s)|_{s=s_t} ] Use the actor's online network to get the action mean values using the current states as the inputs. Then, use the critic online network in order to get the gradients of the critic output with respect to the action mean values \\nabla _a Q(s,a)|_{s=s_t,a=\\mu(s_t ) } . Using the chain rule, calculate the gradients of the actor's output, with respect to the actor weights, given \\nabla_a Q(s,a) . Finally, apply those gradients to the actor network. After every training step, do a soft update of the critic and actor target networks' weights from the online networks.","title":"Training the network"},{"location":"algorithms/policy_optimization/pg/index.html","text":"Policy Gradient Actions space: Discrete|Continuous References: Simple Statistical Gradient-Following Algorithms for Connectionist Reinforcement Learning Network Structure Algorithm Description Choosing an action - Discrete actions Run the current states through the network and get a policy distribution over the actions. While training, sample from the policy distribution. When testing, take the action with the highest probability. Training the network The policy head loss is defined as L=-log (\\pi) \\cdot PolicyGradientRescaler . The PolicyGradientRescaler is used in order to reduce the policy gradient variance, which might be very noisy. This is done in order to reduce the variance of the updates, since noisy gradient updates might destabilize the policy's convergence. The rescaler is a configurable parameter and there are few options to choose from: Total Episode Return - The sum of all the discounted rewards during the episode. Future Return - Return from each transition until the end of the episode. Future Return Normalized by Episode - Future returns across the episode normalized by the episode's mean and standard deviation. Future Return Normalized by Timestep - Future returns normalized using running means and standard deviations, which are calculated seperately for each timestep, across different episodes. Gradients are accumulated over a number of full played episodes. The gradients accumulation over several episodes serves the same purpose - reducing the update variance. After accumulating gradients for several episodes, the gradients are then applied to the network.","title":"Policy Gradient"},{"location":"algorithms/policy_optimization/pg/index.html#policy-gradient","text":"Actions space: Discrete|Continuous References: Simple Statistical Gradient-Following Algorithms for Connectionist Reinforcement Learning","title":"Policy Gradient"},{"location":"algorithms/policy_optimization/pg/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/policy_optimization/pg/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/policy_optimization/pg/index.html#choosing-an-action-discrete-actions","text":"Run the current states through the network and get a policy distribution over the actions. While training, sample from the policy distribution. When testing, take the action with the highest probability.","title":"Choosing an action - Discrete actions"},{"location":"algorithms/policy_optimization/pg/index.html#training-the-network","text":"The policy head loss is defined as L=-log (\\pi) \\cdot PolicyGradientRescaler . The PolicyGradientRescaler is used in order to reduce the policy gradient variance, which might be very noisy. This is done in order to reduce the variance of the updates, since noisy gradient updates might destabilize the policy's convergence. The rescaler is a configurable parameter and there are few options to choose from: Total Episode Return - The sum of all the discounted rewards during the episode. Future Return - Return from each transition until the end of the episode. Future Return Normalized by Episode - Future returns across the episode normalized by the episode's mean and standard deviation. Future Return Normalized by Timestep - Future returns normalized using running means and standard deviations, which are calculated seperately for each timestep, across different episodes. Gradients are accumulated over a number of full played episodes. The gradients accumulation over several episodes serves the same purpose - reducing the update variance. After accumulating gradients for several episodes, the gradients are then applied to the network.","title":"Training the network"},{"location":"algorithms/policy_optimization/ppo/index.html","text":"Proximal Policy Optimization Actions space: Discrete|Continuous References: Proximal Policy Optimization Algorithms Network Structure Algorithm Description Choosing an action - Continuous actions Run the observation through the policy network, and get the mean and standard deviation vectors for this observation. While in training phase, sample from a multi-dimensional Gaussian distribution with these mean and standard deviation values. When testing, just take the mean values predicted by the network. Training the network Collect a big chunk of experience (in the order of thousands of transitions, sampled from multiple episodes). Calculate the advantages for each transition, using the Generalized Advantage Estimation method (Schulman '2015). Run a single training iteration of the value network using an L-BFGS optimizer. Unlike first order optimizers, the L-BFGS optimizer runs on the entire dataset at once, without batching. It continues running until some low loss threshold is reached. To prevent overfitting to the current dataset, the value targets are updated in a soft manner, using an Exponentially Weighted Moving Average, based on the total discounted returns of each state in each episode. Run several training iterations of the policy network. This is done by using the previously calculated advantages as targets. The loss function penalizes policies that deviate too far from the old policy (the policy that was used before starting to run the current set of training iterations) using a regularization term. After training is done, the last sampled KL divergence value will be compared with the target KL divergence value, in order to adapt the penalty coefficient used in the policy loss. If the KL divergence went too high, increase the penalty, if it went too low, reduce it. Otherwise, leave it unchanged.","title":"Proximal Policy Optimization"},{"location":"algorithms/policy_optimization/ppo/index.html#proximal-policy-optimization","text":"Actions space: Discrete|Continuous References: Proximal Policy Optimization Algorithms","title":"Proximal Policy Optimization"},{"location":"algorithms/policy_optimization/ppo/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/policy_optimization/ppo/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/policy_optimization/ppo/index.html#choosing-an-action-continuous-actions","text":"Run the observation through the policy network, and get the mean and standard deviation vectors for this observation. While in training phase, sample from a multi-dimensional Gaussian distribution with these mean and standard deviation values. When testing, just take the mean values predicted by the network.","title":"Choosing an action - Continuous actions"},{"location":"algorithms/policy_optimization/ppo/index.html#training-the-network","text":"Collect a big chunk of experience (in the order of thousands of transitions, sampled from multiple episodes). Calculate the advantages for each transition, using the Generalized Advantage Estimation method (Schulman '2015). Run a single training iteration of the value network using an L-BFGS optimizer. Unlike first order optimizers, the L-BFGS optimizer runs on the entire dataset at once, without batching. It continues running until some low loss threshold is reached. To prevent overfitting to the current dataset, the value targets are updated in a soft manner, using an Exponentially Weighted Moving Average, based on the total discounted returns of each state in each episode. Run several training iterations of the policy network. This is done by using the previously calculated advantages as targets. The loss function penalizes policies that deviate too far from the old policy (the policy that was used before starting to run the current set of training iterations) using a regularization term. After training is done, the last sampled KL divergence value will be compared with the target KL divergence value, in order to adapt the penalty coefficient used in the policy loss. If the KL divergence went too high, increase the penalty, if it went too low, reduce it. Otherwise, leave it unchanged.","title":"Training the network"},{"location":"algorithms/value_optimization/bs_dqn/index.html","text":"Bootstrapped DQN Actions space: Discrete References: Deep Exploration via Bootstrapped DQN Network Structure Algorithm Description Choosing an action The current states are used as the input to the network. The network contains several Q heads, which are used for returning different estimations of the action Q values. For each episode, the bootstrapped exploration policy selects a single head to play with during the episode. According to the selected head, only the relevant output Q values are used. Using those Q values, the exploration policy then selects the action for acting. Storing the transitions For each transition, a Binomial mask is generated according to a predefined probability, and the number of output heads. The mask is a binary vector where each element holds a 0 for heads that shouldn't train on the specific transition, and 1 for heads that should use the transition for training. The mask is stored as part of the transition info in the replay buffer. Training the network First, sample a batch of transitions from the replay buffer. Run the current states through the network and get the current Q value predictions for all the heads and all the actions. For each transition in the batch, and for each output head, if the transition mask is 1 - change the targets of the played action to y_t , according to the standard DQN update rule: y_t=r(s_t,a_t )+\\gamma\\cdot max_a Q(s_{t+1},a) Otherwise, leave it intact so that the transition does not affect the learning of this head. Then, train the online network according to the calculated targets. As in DQN, once in every few thousand steps, copy the weights from the online network to the target network.","title":"Bootstrapped DQN"},{"location":"algorithms/value_optimization/bs_dqn/index.html#bootstrapped-dqn","text":"Actions space: Discrete References: Deep Exploration via Bootstrapped DQN","title":"Bootstrapped DQN"},{"location":"algorithms/value_optimization/bs_dqn/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/bs_dqn/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/bs_dqn/index.html#choosing-an-action","text":"The current states are used as the input to the network. The network contains several Q heads, which are used for returning different estimations of the action Q values. For each episode, the bootstrapped exploration policy selects a single head to play with during the episode. According to the selected head, only the relevant output Q values are used. Using those Q values, the exploration policy then selects the action for acting.","title":"Choosing an action"},{"location":"algorithms/value_optimization/bs_dqn/index.html#storing-the-transitions","text":"For each transition, a Binomial mask is generated according to a predefined probability, and the number of output heads. The mask is a binary vector where each element holds a 0 for heads that shouldn't train on the specific transition, and 1 for heads that should use the transition for training. The mask is stored as part of the transition info in the replay buffer.","title":"Storing the transitions"},{"location":"algorithms/value_optimization/bs_dqn/index.html#training-the-network","text":"First, sample a batch of transitions from the replay buffer. Run the current states through the network and get the current Q value predictions for all the heads and all the actions. For each transition in the batch, and for each output head, if the transition mask is 1 - change the targets of the played action to y_t , according to the standard DQN update rule: y_t=r(s_t,a_t )+\\gamma\\cdot max_a Q(s_{t+1},a) Otherwise, leave it intact so that the transition does not affect the learning of this head. Then, train the online network according to the calculated targets. As in DQN, once in every few thousand steps, copy the weights from the online network to the target network.","title":"Training the network"},{"location":"algorithms/value_optimization/categorical_dqn/index.html","text":"Categorical DQN Actions space: Discrete References: A Distributional Perspective on Reinforcement Learning Network Structure Algorithm Description Training the network Sample a batch of transitions from the replay buffer. The Bellman update is projected to the set of atoms representing the Q values distribution, such that the i-th component of the projected update is calculated as follows: (\\Phi \\hat{T} Z_{\\theta}(s_t,a_t))_i=\\sum_{j=0}^{N-1}\\Big[1-\\frac{|[\\hat{T}_{z_{j}}]^{V_{MAX}}_{V_{MIN}}-z_i|}{\\Delta z}\\Big]^1_0 \\ p_j(s_{t+1}, \\pi(s_{t+1})) where: [ \\cdot ] bounds its argument in the range [a, b] \\hat{T}_{z_{j}} is the Bellman update for atom z_j : \\hat{T}_{z_{j}} := r+\\gamma z_j Network is trained with the cross entropy loss between the resulting probability distribution and the target probability distribution. Only the target of the actions that were actually taken is updated. Once in every few thousand steps, weights are copied from the online network to the target network.","title":"Categorical DQN"},{"location":"algorithms/value_optimization/categorical_dqn/index.html#categorical-dqn","text":"Actions space: Discrete References: A Distributional Perspective on Reinforcement Learning","title":"Categorical DQN"},{"location":"algorithms/value_optimization/categorical_dqn/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/categorical_dqn/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/categorical_dqn/index.html#training-the-network","text":"Sample a batch of transitions from the replay buffer. The Bellman update is projected to the set of atoms representing the Q values distribution, such that the i-th component of the projected update is calculated as follows: (\\Phi \\hat{T} Z_{\\theta}(s_t,a_t))_i=\\sum_{j=0}^{N-1}\\Big[1-\\frac{|[\\hat{T}_{z_{j}}]^{V_{MAX}}_{V_{MIN}}-z_i|}{\\Delta z}\\Big]^1_0 \\ p_j(s_{t+1}, \\pi(s_{t+1})) where: [ \\cdot ] bounds its argument in the range [a, b] \\hat{T}_{z_{j}} is the Bellman update for atom z_j : \\hat{T}_{z_{j}} := r+\\gamma z_j Network is trained with the cross entropy loss between the resulting probability distribution and the target probability distribution. Only the target of the actions that were actually taken is updated. Once in every few thousand steps, weights are copied from the online network to the target network.","title":"Training the network"},{"location":"algorithms/value_optimization/distributional_dqn/index.html","text":"Distributional DQN Actions space: Discrete References: A Distributional Perspective on Reinforcement Learning Network Structure Algorithmic Description Training the network Sample a batch of transitions from the replay buffer. The Bellman update is projected to the set of atoms representing the Q values distribution, such that the i-th component of the projected update is calculated as follows: (\\Phi \\hat{T} Z_{\\theta}(s_t,a_t))_i=\\sum_{j=0}^{N-1}\\Big[1-\\frac{|[\\hat{T}_{z_{j}}]^{V_{MAX}}_{V_{MIN}}-z_i|}{\\Delta z}\\Big]^1_0 \\ p_j(s_{t+1}, \\pi(s_{t+1})) where: [ \\cdot ] bounds its argument in the range [a, b] \\hat{T}_{z_{j}} is the Bellman update for atom z_j : \\hat{T}_{z_{j}} := r+\\gamma z_j Network is trained with the cross entropy loss between the resulting probability distribution and the target probability distribution. Only the target of the actions that were actually taken is updated. Once in every few thousand steps, weights are copied from the online network to the target network.","title":"Distributional DQN"},{"location":"algorithms/value_optimization/distributional_dqn/index.html#distributional-dqn","text":"Actions space: Discrete References: A Distributional Perspective on Reinforcement Learning","title":"Distributional DQN"},{"location":"algorithms/value_optimization/distributional_dqn/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/distributional_dqn/index.html#algorithmic-description","text":"","title":"Algorithmic Description"},{"location":"algorithms/value_optimization/distributional_dqn/index.html#training-the-network","text":"Sample a batch of transitions from the replay buffer. The Bellman update is projected to the set of atoms representing the Q values distribution, such that the i-th component of the projected update is calculated as follows: (\\Phi \\hat{T} Z_{\\theta}(s_t,a_t))_i=\\sum_{j=0}^{N-1}\\Big[1-\\frac{|[\\hat{T}_{z_{j}}]^{V_{MAX}}_{V_{MIN}}-z_i|}{\\Delta z}\\Big]^1_0 \\ p_j(s_{t+1}, \\pi(s_{t+1})) where: [ \\cdot ] bounds its argument in the range [a, b] \\hat{T}_{z_{j}} is the Bellman update for atom z_j : \\hat{T}_{z_{j}} := r+\\gamma z_j Network is trained with the cross entropy loss between the resulting probability distribution and the target probability distribution. Only the target of the actions that were actually taken is updated. Once in every few thousand steps, weights are copied from the online network to the target network.","title":"Training the network"},{"location":"algorithms/value_optimization/double_dqn/index.html","text":"Double DQN Actions space: Discrete References: Deep Reinforcement Learning with Double Q-learning Network Structure Algorithm Description Training the network Sample a batch of transitions from the replay buffer. Using the next states from the sampled batch, run the online network in order to find the Q maximizing action argmax_a Q(s_{t+1},a) . For these actions, use the corresponding next states and run the target network to calculate Q(s_{t+1},argmax_a Q(s_{t+1},a)) . In order to zero out the updates for the actions that were not played (resulting from zeroing the MSE loss), use the current states from the sampled batch, and run the online network to get the current Q values predictions. Set those values as the targets for the actions that were not actually played. For each action that was played, use the following equation for calculating the targets of the network: y_t=r(s_t,a_t )+\\gamma \\cdot Q(s_{t+1},argmax_a Q(s_{t+1},a)) Finally, train the online network using the current states as inputs, and with the aforementioned targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"Double DQN"},{"location":"algorithms/value_optimization/double_dqn/index.html#double-dqn","text":"Actions space: Discrete References: Deep Reinforcement Learning with Double Q-learning","title":"Double DQN"},{"location":"algorithms/value_optimization/double_dqn/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/double_dqn/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/double_dqn/index.html#training-the-network","text":"Sample a batch of transitions from the replay buffer. Using the next states from the sampled batch, run the online network in order to find the Q maximizing action argmax_a Q(s_{t+1},a) . For these actions, use the corresponding next states and run the target network to calculate Q(s_{t+1},argmax_a Q(s_{t+1},a)) . In order to zero out the updates for the actions that were not played (resulting from zeroing the MSE loss), use the current states from the sampled batch, and run the online network to get the current Q values predictions. Set those values as the targets for the actions that were not actually played. For each action that was played, use the following equation for calculating the targets of the network: y_t=r(s_t,a_t )+\\gamma \\cdot Q(s_{t+1},argmax_a Q(s_{t+1},a)) Finally, train the online network using the current states as inputs, and with the aforementioned targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"Training the network"},{"location":"algorithms/value_optimization/dqn/index.html","text":"Deep Q Networks Actions space: Discrete References: Playing Atari with Deep Reinforcement Learning Network Structure Algorithm Description Training the network Sample a batch of transitions from the replay buffer. Using the next states from the sampled batch, run the target network to calculate the Q values for each of the actions Q(s_{t+1},a) , and keep only the maximum value for each state. In order to zero out the updates for the actions that were not played (resulting from zeroing the MSE loss), use the current states from the sampled batch, and run the online network to get the current Q values predictions. Set those values as the targets for the actions that were not actually played. For each action that was played, use the following equation for calculating the targets of the network:\u200b y_t=r(s_t,a_t)+\u03b3\\cdot max_a {Q(s_{t+1},a)} Finally, train the online network using the current states as inputs, and with the aforementioned targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"DQN"},{"location":"algorithms/value_optimization/dqn/index.html#deep-q-networks","text":"Actions space: Discrete References: Playing Atari with Deep Reinforcement Learning","title":"Deep Q Networks"},{"location":"algorithms/value_optimization/dqn/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/dqn/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/dqn/index.html#training-the-network","text":"Sample a batch of transitions from the replay buffer. Using the next states from the sampled batch, run the target network to calculate the Q values for each of the actions Q(s_{t+1},a) , and keep only the maximum value for each state. In order to zero out the updates for the actions that were not played (resulting from zeroing the MSE loss), use the current states from the sampled batch, and run the online network to get the current Q values predictions. Set those values as the targets for the actions that were not actually played. For each action that was played, use the following equation for calculating the targets of the network:\u200b y_t=r(s_t,a_t)+\u03b3\\cdot max_a {Q(s_{t+1},a)} Finally, train the online network using the current states as inputs, and with the aforementioned targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"Training the network"},{"location":"algorithms/value_optimization/dueling_dqn/index.html","text":"Dueling DQN Actions space: Discrete References: Dueling Network Architectures for Deep Reinforcement Learning Network Structure General Description Dueling DQN presents a change in the network structure comparing to DQN. Dueling DQN uses a specialized Dueling Q Head in order to separate Q to an A (advantage) stream and a V stream. Adding this type of structure to the network head allows the network to better differentiate actions from one another, and significantly improves the learning. In many states, the values of the different actions are very similar, and it is less important which action to take. This is especially important in environments where there are many actions to choose from. In DQN, on each training iteration, for each of the states in the batch, we update the Q values only for the specific actions taken in those states. This results in slower learning as we do not learn the Q values for actions that were not taken yet. On dueling architecture, on the other hand, learning is faster - as we start learning the state-value even if only a single action has been taken at this state.","title":"Dueling DQN"},{"location":"algorithms/value_optimization/dueling_dqn/index.html#dueling-dqn","text":"Actions space: Discrete References: Dueling Network Architectures for Deep Reinforcement Learning","title":"Dueling DQN"},{"location":"algorithms/value_optimization/dueling_dqn/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/dueling_dqn/index.html#general-description","text":"Dueling DQN presents a change in the network structure comparing to DQN. Dueling DQN uses a specialized Dueling Q Head in order to separate Q to an A (advantage) stream and a V stream. Adding this type of structure to the network head allows the network to better differentiate actions from one another, and significantly improves the learning. In many states, the values of the different actions are very similar, and it is less important which action to take. This is especially important in environments where there are many actions to choose from. In DQN, on each training iteration, for each of the states in the batch, we update the Q values only for the specific actions taken in those states. This results in slower learning as we do not learn the Q values for actions that were not taken yet. On dueling architecture, on the other hand, learning is faster - as we start learning the state-value even if only a single action has been taken at this state.","title":"General Description"},{"location":"algorithms/value_optimization/mmc/index.html","text":"Mixed Monte Carlo Actions space: Discrete References: Count-Based Exploration with Neural Density Models Network Structure Algorithm Description Training the network In MMC, targets are calculated as a mixture between Double DQN targets and full Monte Carlo samples (total discounted returns). The DDQN targets are calculated in the same manner as in the DDQN agent: y_t^{DDQN}=r(s_t,a_t )+\\gamma Q(s_{t+1},argmax_a Q(s_{t+1},a)) The Monte Carlo targets are calculated by summing up the discounted rewards across the entire episode: y_t^{MC}=\\sum_{j=0}^T\\gamma^j r(s_{t+j},a_{t+j} ) A mixing ratio \\alpha is then used to get the final targets: y_t=(1-\\alpha)\\cdot y_t^{DDQN}+\\alpha \\cdot y_t^{MC} Finally, the online network is trained using the current states as inputs, and the calculated targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"Mixed Monte Carlo"},{"location":"algorithms/value_optimization/mmc/index.html#mixed-monte-carlo","text":"Actions space: Discrete References: Count-Based Exploration with Neural Density Models","title":"Mixed Monte Carlo"},{"location":"algorithms/value_optimization/mmc/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/mmc/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/mmc/index.html#training-the-network","text":"In MMC, targets are calculated as a mixture between Double DQN targets and full Monte Carlo samples (total discounted returns). The DDQN targets are calculated in the same manner as in the DDQN agent: y_t^{DDQN}=r(s_t,a_t )+\\gamma Q(s_{t+1},argmax_a Q(s_{t+1},a)) The Monte Carlo targets are calculated by summing up the discounted rewards across the entire episode: y_t^{MC}=\\sum_{j=0}^T\\gamma^j r(s_{t+j},a_{t+j} ) A mixing ratio \\alpha is then used to get the final targets: y_t=(1-\\alpha)\\cdot y_t^{DDQN}+\\alpha \\cdot y_t^{MC} Finally, the online network is trained using the current states as inputs, and the calculated targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"Training the network"},{"location":"algorithms/value_optimization/n_step/index.html","text":"N-Step Q Learning Actions space: Discrete References: Asynchronous Methods for Deep Reinforcement Learning Network Structure Algorithm Description Training the network The N -step Q learning algorithm works in similar manner to DQN except for the following changes: No replay buffer is used. Instead of sampling random batches of transitions, the network is trained every N steps using the latest N steps played by the agent. In order to stabilize the learning, multiple workers work together to update the network. This creates the same effect as uncorrelating the samples used for training. Instead of using single-step Q targets for the network, the rewards from N consequent steps are accumulated to form the N -step Q targets, according to the following equation: R(s_t, a_t) = \\sum_{i=t}^{i=t + k - 1} \\gamma^{i-t}r_i +\\gamma^{k} V(s_{t+k}) where k is T_{max} - State\\_Index for each state in the batch","title":"N-Step Q Learning"},{"location":"algorithms/value_optimization/n_step/index.html#n-step-q-learning","text":"Actions space: Discrete References: Asynchronous Methods for Deep Reinforcement Learning","title":"N-Step Q Learning"},{"location":"algorithms/value_optimization/n_step/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/n_step/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/n_step/index.html#training-the-network","text":"The N -step Q learning algorithm works in similar manner to DQN except for the following changes: No replay buffer is used. Instead of sampling random batches of transitions, the network is trained every N steps using the latest N steps played by the agent. In order to stabilize the learning, multiple workers work together to update the network. This creates the same effect as uncorrelating the samples used for training. Instead of using single-step Q targets for the network, the rewards from N consequent steps are accumulated to form the N -step Q targets, according to the following equation: R(s_t, a_t) = \\sum_{i=t}^{i=t + k - 1} \\gamma^{i-t}r_i +\\gamma^{k} V(s_{t+k}) where k is T_{max} - State\\_Index for each state in the batch","title":"Training the network"},{"location":"algorithms/value_optimization/naf/index.html","text":"Normalized Advantage Functions Actions space: Continuous References: Continuous Deep Q-Learning with Model-based Acceleration Network Structure Algorithm Description Choosing an action The current state is used as an input to the network. The action mean \\mu(s_t ) is extracted from the output head. It is then passed to the exploration policy which adds noise in order to encourage exploration. Training the network The network is trained by using the following targets: y_t=r(s_t,a_t )+\\gamma\\cdot V(s_{t+1}) Use the next states as the inputs to the target network and extract the V value, from within the head, to get V(s_{t+1} ) . Then, update the online network using the current states and actions as inputs, and y_t as the targets. After every training step, use a soft update in order to copy the weights from the online network to the target network.","title":"Normalized Advantage Functions"},{"location":"algorithms/value_optimization/naf/index.html#normalized-advantage-functions","text":"Actions space: Continuous References: Continuous Deep Q-Learning with Model-based Acceleration","title":"Normalized Advantage Functions"},{"location":"algorithms/value_optimization/naf/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/naf/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/naf/index.html#choosing-an-action","text":"The current state is used as an input to the network. The action mean \\mu(s_t ) is extracted from the output head. It is then passed to the exploration policy which adds noise in order to encourage exploration.","title":"Choosing an action"},{"location":"algorithms/value_optimization/naf/index.html#training-the-network","text":"The network is trained by using the following targets: y_t=r(s_t,a_t )+\\gamma\\cdot V(s_{t+1}) Use the next states as the inputs to the target network and extract the V value, from within the head, to get V(s_{t+1} ) . Then, update the online network using the current states and actions as inputs, and y_t as the targets. After every training step, use a soft update in order to copy the weights from the online network to the target network.","title":"Training the network"},{"location":"algorithms/value_optimization/nec/index.html","text":"Neural Episodic Control Actions space: Discrete References: Neural Episodic Control Network Structure Algorithm Description Choosing an action Use the current state as an input to the online network and extract the state embedding, which is the intermediate output from the middleware. For each possible action a_i , run the DND head using the state embedding and the selected action a_i as inputs. The DND is queried and returns the P nearest neighbor keys and values. The keys and values are used to calculate and return the action Q value from the network. Pass all the Q values to the exploration policy and choose an action accordingly. Store the state embeddings and actions taken during the current episode in a small buffer B , in order to accumulate transitions until it is possible to calculate the total discounted returns over the entire episode. Finalizing an episode For each step in the episode, the state embeddings and the taken actions are stored in the buffer B . When the episode is finished, the replay buffer calculates the N -step total return of each transition in the buffer, bootstrapped using the maximum Q value of the N -th transition. Those values are inserted along with the total return into the DND, and the buffer B is reset. Training the network Train the network only when the DND has enough entries for querying. To train the network, the current states are used as the inputs and the N -step returns are used as the targets. The N -step return used takes into account N consecutive steps, and bootstraps the last value from the network if necessary: y_t=\\sum_{j=0}^{N-1}\\gamma^j r(s_{t+j},a_{t+j} ) +\\gamma^N max_a Q(s_{t+N},a)","title":"Neural Episodic Control"},{"location":"algorithms/value_optimization/nec/index.html#neural-episodic-control","text":"Actions space: Discrete References: Neural Episodic Control","title":"Neural Episodic Control"},{"location":"algorithms/value_optimization/nec/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/nec/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/nec/index.html#choosing-an-action","text":"Use the current state as an input to the online network and extract the state embedding, which is the intermediate output from the middleware. For each possible action a_i , run the DND head using the state embedding and the selected action a_i as inputs. The DND is queried and returns the P nearest neighbor keys and values. The keys and values are used to calculate and return the action Q value from the network. Pass all the Q values to the exploration policy and choose an action accordingly. Store the state embeddings and actions taken during the current episode in a small buffer B , in order to accumulate transitions until it is possible to calculate the total discounted returns over the entire episode.","title":"Choosing an action"},{"location":"algorithms/value_optimization/nec/index.html#finalizing-an-episode","text":"For each step in the episode, the state embeddings and the taken actions are stored in the buffer B . When the episode is finished, the replay buffer calculates the N -step total return of each transition in the buffer, bootstrapped using the maximum Q value of the N -th transition. Those values are inserted along with the total return into the DND, and the buffer B is reset.","title":"Finalizing an episode"},{"location":"algorithms/value_optimization/nec/index.html#training-the-network","text":"Train the network only when the DND has enough entries for querying. To train the network, the current states are used as the inputs and the N -step returns are used as the targets. The N -step return used takes into account N consecutive steps, and bootstraps the last value from the network if necessary: y_t=\\sum_{j=0}^{N-1}\\gamma^j r(s_{t+j},a_{t+j} ) +\\gamma^N max_a Q(s_{t+N},a)","title":"Training the network"},{"location":"algorithms/value_optimization/pal/index.html","text":"Persistent Advantage Learning Actions space: Discrete References: Increasing the Action Gap: New Operators for Reinforcement Learning Network Structure Algorithm Description Training the network Sample a batch of transitions from the replay buffer. Start by calculating the initial target values in the same manner as they are calculated in DDQN y_t^{DDQN}=r(s_t,a_t )+\\gamma Q(s_{t+1},argmax_a Q(s_{t+1},a)) The action gap V(s_t )-Q(s_t,a_t) should then be subtracted from each of the calculated targets. To calculate the action gap, run the target network using the current states and get the Q values for all the actions. Then estimate V as the maximum predicted Q value for the current state: V(s_t )=max_a Q(s_t,a) For advantage learning (AL) , reduce the action gap weighted by a predefined parameter \\alpha from the targets y_t^{DDQN} : y_t=y_t^{DDQN}-\\alpha \\cdot (V(s_t )-Q(s_t,a_t )) For persistent advantage learning (PAL) , the target network is also used in order to calculate the action gap for the next state: V(s_{t+1} )-Q(s_{t+1},a_{t+1}) where a_{t+1} is chosen by running the next states through the online network and choosing the action that has the highest predicted Q value. Finally, the targets will be defined as - y_t=y_t^{DDQN}-\\alpha \\cdot min(V(s_t )-Q(s_t,a_t ),V(s_{t+1} )-Q(s_{t+1},a_{t+1} )) Train the online network using the current states as inputs, and with the aforementioned targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"Persistent Advantage Learning"},{"location":"algorithms/value_optimization/pal/index.html#persistent-advantage-learning","text":"Actions space: Discrete References: Increasing the Action Gap: New Operators for Reinforcement Learning","title":"Persistent Advantage Learning"},{"location":"algorithms/value_optimization/pal/index.html#network-structure","text":"","title":"Network Structure"},{"location":"algorithms/value_optimization/pal/index.html#algorithm-description","text":"","title":"Algorithm Description"},{"location":"algorithms/value_optimization/pal/index.html#training-the-network","text":"Sample a batch of transitions from the replay buffer. Start by calculating the initial target values in the same manner as they are calculated in DDQN y_t^{DDQN}=r(s_t,a_t )+\\gamma Q(s_{t+1},argmax_a Q(s_{t+1},a)) The action gap V(s_t )-Q(s_t,a_t) should then be subtracted from each of the calculated targets. To calculate the action gap, run the target network using the current states and get the Q values for all the actions. Then estimate V as the maximum predicted Q value for the current state: V(s_t )=max_a Q(s_t,a) For advantage learning (AL) , reduce the action gap weighted by a predefined parameter \\alpha from the targets y_t^{DDQN} : y_t=y_t^{DDQN}-\\alpha \\cdot (V(s_t )-Q(s_t,a_t )) For persistent advantage learning (PAL) , the target network is also used in order to calculate the action gap for the next state: V(s_{t+1} )-Q(s_{t+1},a_{t+1}) where a_{t+1} is chosen by running the next states through the online network and choosing the action that has the highest predicted Q value. Finally, the targets will be defined as - y_t=y_t^{DDQN}-\\alpha \\cdot min(V(s_t )-Q(s_t,a_t ),V(s_{t+1} )-Q(s_{t+1},a_{t+1} )) Train the online network using the current states as inputs, and with the aforementioned targets. Once in every few thousand steps, copy the weights from the online network to the target network.","title":"Training the network"},{"location":"api_reference/agent_parameters/agent_parameters/index.html","text":"Agent Parameters Each agent should have a dedicated parameters class which inherits from AgentParameters, and instantiates it with the following parameters: algorithm: (AlgorithmParameters) \"\"\" :param algorithm: the algorithmic parameters :param exploration: the exploration policy parameters :param memory: the memory module parameters :param networks: the parameters for the networks of the agent :param visualization: the visualization parameters \"\"\"","title":"Agent Parameters"},{"location":"api_reference/agent_parameters/agent_parameters/index.html#agent-parameters","text":"Each agent should have a dedicated parameters class which inherits from AgentParameters, and instantiates it with the following parameters: algorithm: (AlgorithmParameters) \"\"\" :param algorithm: the algorithmic parameters :param exploration: the exploration policy parameters :param memory: the memory module parameters :param networks: the parameters for the networks of the agent :param visualization: the visualization parameters \"\"\"","title":"Agent Parameters"},{"location":"contributing/add_agent/index.html","text":"Coach's modularity makes adding an agent a simple and clean task, that involves the following steps: Implement your algorithm in a new file. The agent can inherit base classes such as ValueOptimizationAgent or ActorCriticAgent , or the more generic Agent base class. ValueOptimizationAgent , PolicyOptimizationAgent and Agent are abstract classes. learn_from_batch() should be overriden with the desired behavior for the algorithm being implemented. If deciding to inherit from Agent , also choose_action() should be overriden. def learn_from_batch(self, batch) -> Tuple[float, List, List]: \"\"\" Given a batch of transitions, calculates their target values and updates the network. :param batch: A list of transitions :return: The total loss of the training, the loss per head and the unclipped gradients \"\"\" def choose_action(self, curr_state): \"\"\" choose an action to act with in the current episode being played. Different behavior might be exhibited when training or testing. :param curr_state: the current state to act upon. :return: chosen action, some action value describing the action (q-value, probability, etc) \"\"\" Implement your agent's specific network head, if needed, at the implementation for the framework of your choice. For example architectures/neon_components/heads.py . The head will inherit the generic base class Head. A new output type should be added to configurations.py, and a mapping between the new head and output type should be defined in the get_output_head() function at architectures/neon_components/general_network.py Define a new parameters class that inherits AgentParameters. The parameters class defines all the hyperparameters for the agent, and is initialized with 4 main components: algorithm : A class inheriting AlgorithmParameters which defines any algorithm specific parameters exploration : A class inheriting ExplorationParameters which defines the exploration policy parameters. There are several common exploration policies built-in which you can use, and are defined under the exploration sub directory. You can also define your own custom exploration policy. memory : A class inheriting MemoryParameters which defined the memory parameters. There are several common memory types built-in which you can use, and are defined under the memories sub directory. You can also define your own custom memory. networks : A dictionary defining all the networks that will be used by the agent. The keys of the dictionary define the network name and will be used to access each network through the agent class. The dictionary values are a class inheriting NetworkParameters, which define the network structure and parameters. Additionally, set the path property to return the path to your agent class in the following format: <path to python module>:<name of agent class> For example, class RainbowAgentParameters(AgentParameters): def __init__(self): super().__init__(algorithm=RainbowAlgorithmParameters(), exploration=RainbowExplorationParameters(), memory=RainbowMemoryParameters(), networks={\"main\": RainbowNetworkParameters()}) @property def path(self): return 'rainbow.rainbow_agent:RainbowAgent' (Optional) Define a preset using the new agent type with a given environment, and the hyper-parameters that should be used for training on that environment.","title":"Adding a New Agent"},{"location":"contributing/add_env/index.html","text":"Adding a new environment to Coach is as easy as solving CartPole. There are essentially two ways to integrate new environments to Coach: Using the OpenAI Gym API If your environment is already using the OpenAI Gym API, you are already good to go. When selecting the environment parameters in the preset, use GymEnvironmentParameters(), and pass the path to your environment source code using the level parameter. You can specify additional parameters for your environment using the additional_simulator_parameters parameter. Take for example the definition used in the Pendulum_HAC preset: env_params = GymEnvironmentParameters() env_params.level = \"rl_coach.environments.mujoco.pendulum_with_goals:PendulumWithGoals\" env_params.additional_simulator_parameters = {\"time_limit\": 1000} Using the Coach API There are a few simple steps to follow, and we will walk through them one by one. Create a new class for your environment, and inherit the Environment class. Coach defines a simple API for implementing a new environment, which are defined in environment/environment.py. There are several functions to implement, but only some of them are mandatory. Here are the important ones: def _take_action(self, action_idx: ActionType) -> None: \"\"\" An environment dependent function that sends an action to the simulator. :param action_idx: the action to perform on the environment :return: None \"\"\" def _update_state(self) -> None: \"\"\" Updates the state from the environment. Should update self.observation, self.reward, self.done, self.measurements and self.info :return: None \"\"\" def _restart_environment_episode(self, force_environment_reset=False) -> None: \"\"\" Restarts the simulator episode :param force_environment_reset: Force the environment to reset even if the episode is not done yet. :return: None \"\"\" def _render(self) -> None: \"\"\" Renders the environment using the native simulator renderer :return: None \"\"\" def get_rendered_image(self) -> np.ndarray: \"\"\" Return a numpy array containing the image that will be rendered to the screen. This can be different from the observation. For example, mujoco's observation is a measurements vector. :return: numpy array containing the image that will be rendered to the screen \"\"\" Create a new parameters class for your environment, which inherits the EnvironmentParameters class. In the init of your class, define all the parameters you used in your Environment class. Additionally, fill the path property of the class with the path to your Environment class. For example, take a look at the EnvironmentParameters class used for Doom: class DoomEnvironmentParameters(EnvironmentParameters): def __init__(self): super().__init__() self.default_input_filter = DoomInputFilter self.default_output_filter = DoomOutputFilter self.cameras = [DoomEnvironment.CameraTypes.OBSERVATION] @property def path(self): return 'rl_coach.environments.doom_environment:DoomEnvironment' And that's it, you're done. Now just add a new preset with your newly created environment, and start training an agent on top of it.","title":"Adding a New Environment"},{"location":"contributing/add_env/index.html#using-the-openai-gym-api","text":"If your environment is already using the OpenAI Gym API, you are already good to go. When selecting the environment parameters in the preset, use GymEnvironmentParameters(), and pass the path to your environment source code using the level parameter. You can specify additional parameters for your environment using the additional_simulator_parameters parameter. Take for example the definition used in the Pendulum_HAC preset: env_params = GymEnvironmentParameters() env_params.level = \"rl_coach.environments.mujoco.pendulum_with_goals:PendulumWithGoals\" env_params.additional_simulator_parameters = {\"time_limit\": 1000}","title":"Using the OpenAI Gym API"},{"location":"contributing/add_env/index.html#using-the-coach-api","text":"There are a few simple steps to follow, and we will walk through them one by one. Create a new class for your environment, and inherit the Environment class. Coach defines a simple API for implementing a new environment, which are defined in environment/environment.py. There are several functions to implement, but only some of them are mandatory. Here are the important ones: def _take_action(self, action_idx: ActionType) -> None: \"\"\" An environment dependent function that sends an action to the simulator. :param action_idx: the action to perform on the environment :return: None \"\"\" def _update_state(self) -> None: \"\"\" Updates the state from the environment. Should update self.observation, self.reward, self.done, self.measurements and self.info :return: None \"\"\" def _restart_environment_episode(self, force_environment_reset=False) -> None: \"\"\" Restarts the simulator episode :param force_environment_reset: Force the environment to reset even if the episode is not done yet. :return: None \"\"\" def _render(self) -> None: \"\"\" Renders the environment using the native simulator renderer :return: None \"\"\" def get_rendered_image(self) -> np.ndarray: \"\"\" Return a numpy array containing the image that will be rendered to the screen. This can be different from the observation. For example, mujoco's observation is a measurements vector. :return: numpy array containing the image that will be rendered to the screen \"\"\" Create a new parameters class for your environment, which inherits the EnvironmentParameters class. In the init of your class, define all the parameters you used in your Environment class. Additionally, fill the path property of the class with the path to your Environment class. For example, take a look at the EnvironmentParameters class used for Doom: class DoomEnvironmentParameters(EnvironmentParameters): def __init__(self): super().__init__() self.default_input_filter = DoomInputFilter self.default_output_filter = DoomOutputFilter self.cameras = [DoomEnvironment.CameraTypes.OBSERVATION] @property def path(self): return 'rl_coach.environments.doom_environment:DoomEnvironment' And that's it, you're done. Now just add a new preset with your newly created environment, and start training an agent on top of it.","title":"Using the Coach API"},{"location":"design/control_flow/index.html","text":"Coach Control Flow Coach is built in a modular way, encouraging modules reuse and reducing the amount of boilerplate code needed for developing new algorithms or integrating a new challenge as an environment. On the other hand, it can be overwhelming for new users to ramp up on the code. To help with that, here's a short overview of the control flow. Graph Manager The main entry point for Coach is coach.py . The main functionality of this script is to parse the command line arguments and invoke all the sub-processes needed for the given experiment. coach.py executes the given preset file which returns a GraphManager object. A preset is a design pattern that is intended for concentrating the entire definition of an experiment in a single file. This helps with experiments reproducibility, improves readability and prevents confusion. The outcome of a preset is a GraphManager which will usually be instantiated in the final lines of the preset. A GraphManager is an object that holds all the agents and environments of an experiment, and is mostly responsible for scheduling their work. Why is it called a graph manager? Because agents and environments are structured into a graph of interactions. For example, in hierarchical reinforcement learning schemes, there will often be a master policy agent, that will control a sub-policy agent, which will interact with the environment. Other schemes can have much more complex graphs of control, such as several hierarchy layers, each with multiple agents. The graph manager's main loop is the improve loop. The improve loop skips between 3 main phases - heatup, training and evaluation: Heatup - the goal of this phase is to collect initial data for populating the replay buffers. The heatup phase takes place only in the beginning of the experiment, and the agents will act completely randomly during this phase. Importantly, the agents do not train their networks during this phase. DQN for example, uses 50k random steps in order to initialize the replay buffers. Training - the training phase is the main phase of the experiment. This phase can change between agent types, but essentially consists of repeated cycles of acting, collecting data from the environment, and training the agent networks. During this phase, the agent will use its exploration policy in training mode, which will add noise to its actions in order to improve its knowledge about the environment state space. Evaluation - the evaluation phase is intended for evaluating the current performance of the agent. The agents will act greedily in order to exploit the knowledge aggregated so far and the performance over multiple episodes of evaluation will be averaged in order to reduce the stochasticity effects of all the components. Level Manager In each of the 3 phases described above, the graph manager will invoke all the hierarchy levels in the graph in a synchronized manner. In Coach, agents do not interact directly with the environment. Instead, they go through a LevelManager , which is a proxy that manages their interaction. The level manager passes the current state and reward from the environment to the agent, and the actions from the agent to the environment. The motivation for having a level manager is to disentangle the code of the environment and the agent, so to allow more complex interactions. Each level can have multiple agents which interact with the environment. Who gets to choose the action for each step is controlled by the level manager. Additionally, each level manager can act as an environment for the hierarchy level above it, such that each hierarchy level can be seen as an interaction between an agent and an environment, even if the environment is just more agents in a lower hierarchy level. Agent The base agent class has 3 main function that will be used during those phases - observe, act and train. Observe - this function gets the latest response from the environment as input, and updates the internal state of the agent with the new information. The environment response will be first passed through the agent's InputFilter object, which will process the values in the response, according to the specific agent definition. The environment response will then be converted into a Transition which will contain the information from a single step ( s_{t}, a_{t}, r_{t}, s_{t+1}, terminal signal ), and store it in the memory. Act - this function uses the current internal state of the agent in order to select the next action to take on the environment. This function will call the per-agent custom function choose_action that will use the network and the exploration policy in order to select an action. The action will be stored, together with any additional information (like the action value for example) in an ActionInfo object. The ActionInfo object will then be passed through the agent's OutputFilter to allow any processing of the action (like discretization, or shifting, for example), before passing it to the environment. Train - this function will sample a batch from the memory and train on it. The batch of transitions will be first wrapped into a Batch object to allow efficient querying of the batch values. It will then be passed into the agent specific learn_from_batch function, that will extract network target values from the batch and will train the networks accordingly. Lastly, if there's a target network defined for the agent, it will sync the target network weights with the online network.","title":"Control Flow"},{"location":"design/control_flow/index.html#coach-control-flow","text":"Coach is built in a modular way, encouraging modules reuse and reducing the amount of boilerplate code needed for developing new algorithms or integrating a new challenge as an environment. On the other hand, it can be overwhelming for new users to ramp up on the code. To help with that, here's a short overview of the control flow.","title":"Coach Control Flow"},{"location":"design/control_flow/index.html#graph-manager","text":"The main entry point for Coach is coach.py . The main functionality of this script is to parse the command line arguments and invoke all the sub-processes needed for the given experiment. coach.py executes the given preset file which returns a GraphManager object. A preset is a design pattern that is intended for concentrating the entire definition of an experiment in a single file. This helps with experiments reproducibility, improves readability and prevents confusion. The outcome of a preset is a GraphManager which will usually be instantiated in the final lines of the preset. A GraphManager is an object that holds all the agents and environments of an experiment, and is mostly responsible for scheduling their work. Why is it called a graph manager? Because agents and environments are structured into a graph of interactions. For example, in hierarchical reinforcement learning schemes, there will often be a master policy agent, that will control a sub-policy agent, which will interact with the environment. Other schemes can have much more complex graphs of control, such as several hierarchy layers, each with multiple agents. The graph manager's main loop is the improve loop. The improve loop skips between 3 main phases - heatup, training and evaluation: Heatup - the goal of this phase is to collect initial data for populating the replay buffers. The heatup phase takes place only in the beginning of the experiment, and the agents will act completely randomly during this phase. Importantly, the agents do not train their networks during this phase. DQN for example, uses 50k random steps in order to initialize the replay buffers. Training - the training phase is the main phase of the experiment. This phase can change between agent types, but essentially consists of repeated cycles of acting, collecting data from the environment, and training the agent networks. During this phase, the agent will use its exploration policy in training mode, which will add noise to its actions in order to improve its knowledge about the environment state space. Evaluation - the evaluation phase is intended for evaluating the current performance of the agent. The agents will act greedily in order to exploit the knowledge aggregated so far and the performance over multiple episodes of evaluation will be averaged in order to reduce the stochasticity effects of all the components.","title":"Graph Manager"},{"location":"design/control_flow/index.html#level-manager","text":"In each of the 3 phases described above, the graph manager will invoke all the hierarchy levels in the graph in a synchronized manner. In Coach, agents do not interact directly with the environment. Instead, they go through a LevelManager , which is a proxy that manages their interaction. The level manager passes the current state and reward from the environment to the agent, and the actions from the agent to the environment. The motivation for having a level manager is to disentangle the code of the environment and the agent, so to allow more complex interactions. Each level can have multiple agents which interact with the environment. Who gets to choose the action for each step is controlled by the level manager. Additionally, each level manager can act as an environment for the hierarchy level above it, such that each hierarchy level can be seen as an interaction between an agent and an environment, even if the environment is just more agents in a lower hierarchy level.","title":"Level Manager"},{"location":"design/control_flow/index.html#agent","text":"The base agent class has 3 main function that will be used during those phases - observe, act and train. Observe - this function gets the latest response from the environment as input, and updates the internal state of the agent with the new information. The environment response will be first passed through the agent's InputFilter object, which will process the values in the response, according to the specific agent definition. The environment response will then be converted into a Transition which will contain the information from a single step ( s_{t}, a_{t}, r_{t}, s_{t+1}, terminal signal ), and store it in the memory. Act - this function uses the current internal state of the agent in order to select the next action to take on the environment. This function will call the per-agent custom function choose_action that will use the network and the exploration policy in order to select an action. The action will be stored, together with any additional information (like the action value for example) in an ActionInfo object. The ActionInfo object will then be passed through the agent's OutputFilter to allow any processing of the action (like discretization, or shifting, for example), before passing it to the environment. Train - this function will sample a batch from the memory and train on it. The batch of transitions will be first wrapped into a Batch object to allow efficient querying of the batch values. It will then be passed into the agent specific learn_from_batch function, that will extract network target values from the batch and will train the networks accordingly. Lastly, if there's a target network defined for the agent, it will sync the target network weights with the online network.","title":"Agent"},{"location":"design/features/index.html","text":"Coach Features Supported Algorithms Coach supports many state-of-the-art reinforcement learning algorithms, which are separated into two main classes - value optimization and policy optimization. A detailed description of those algorithms may be found in the algorithms section. Supported Environments Coach supports a large number of environments which can be solved using reinforcement learning: DeepMind Control Suite - a set of reinforcement learning environments powered by the MuJoCo physics engine. Blizzard Starcraft II - a popular strategy game which was wrapped with a python interface by DeepMind. ViZDoom - a Doom-based AI research platform for reinforcement learning from raw visual information. CARLA - an open-source simulator for autonomous driving research. OpenAI Gym - a library which consists of a set of environments, from games to robotics. Additionally, it can be extended using the API defined by the authors. In Coach, we support all the native environments in Gym, along with several extensions such as: Roboschool - a set of environments powered by the PyBullet engine, that offer a free alternative to MuJoCo. Gym Extensions - a set of environments that extends Gym for auxiliary tasks (multitask learning, transfer learning, inverse reinforcement learning, etc.) PyBullet - a physics engine that includes a set of robotics environments.","title":"Features"},{"location":"design/features/index.html#coach-features","text":"","title":"Coach Features"},{"location":"design/features/index.html#supported-algorithms","text":"Coach supports many state-of-the-art reinforcement learning algorithms, which are separated into two main classes - value optimization and policy optimization. A detailed description of those algorithms may be found in the algorithms section.","title":"Supported Algorithms"},{"location":"design/features/index.html#supported-environments","text":"Coach supports a large number of environments which can be solved using reinforcement learning: DeepMind Control Suite - a set of reinforcement learning environments powered by the MuJoCo physics engine. Blizzard Starcraft II - a popular strategy game which was wrapped with a python interface by DeepMind. ViZDoom - a Doom-based AI research platform for reinforcement learning from raw visual information. CARLA - an open-source simulator for autonomous driving research. OpenAI Gym - a library which consists of a set of environments, from games to robotics. Additionally, it can be extended using the API defined by the authors. In Coach, we support all the native environments in Gym, along with several extensions such as: Roboschool - a set of environments powered by the PyBullet engine, that offer a free alternative to MuJoCo. Gym Extensions - a set of environments that extends Gym for auxiliary tasks (multitask learning, transfer learning, inverse reinforcement learning, etc.) PyBullet - a physics engine that includes a set of robotics environments.","title":"Supported Environments"},{"location":"design/filters/index.html","text":"Filters Filters are a mechanism in Coach that allows doing pre-processing and post-processing of the internal agent information. There are two filter categories - Input filters - these are filters that process the information passed into the agent from the environment. This information includes the observation and the reward. Input filters therefore allow rescaling observations, normalizing rewards, stack observations, etc. Output filters - these are filters that process the information going out of the agent into the environment. This information includes the action the agent chooses to take. Output filters therefore allow conversion of actions from one space into another. For example, the agent can take N discrete actions, that will be mapped by the output filter onto N continuous actions. Filters can be stacked on top of each other in order to build complex processing flows of the inputs or outputs. Input Filters The input filters are separated into two categories - observation filters and reward filters . Observation Filters ObservationClippingFilter - Clips the observation values to a given range of values. For example, if the observation consists of measurements in an arbitrary range, and we want to control the minimum and maximum values of these observations, we can define a range and clip the values of the measurements. ObservationCropFilter - Crops the size of the observation to a given crop window. For example, in Atari, the observations are images with a shape of 210x160. Usually, we will want to crop the size of the observation to a square of 160x160 before rescaling them. ObservationMoveAxisFilter - Reorders the axes of the observation. This can be useful when the observation is an image, and we want to move the channel axis to be the last axis instead of the first axis. ObservationNormalizationFilter - Normalizes the observation values with a running mean and standard deviation of all the observations seen so far. The normalization is performed element-wise. Additionally, when working with multiple workers, the statistics used for the normalization operation are accumulated over all the workers. ObservationReductionBySubPartsNameFilter - Allows keeping only parts of the observation, by specifying their name. For example, the CARLA environment extracts multiple measurements that can be used by the agent, such as speed and location. If we want to only use the speed, it can be done using this filter. ObservationRescaleSizeByFactorFilter - Rescales an image observation by some factor. For example, the image size can be reduced by a factor of 2. ObservationRescaleToSizeFilter - Rescales an image observation to a given size. The target size does not necessarily keep the aspect ratio of the original observation. ObservationRGBToYFilter - Converts a color image observation specified using the RGB encoding into a grayscale image observation, by keeping only the luminance (Y) channel of the YUV encoding. This can be useful if the colors in the original image are not relevant for solving the task at hand. ObservationSqueezeFilter - Removes redundant axes from the observation, which are axes with a dimension of 1. ObservationStackingFilter - Stacks several observations on top of each other. For image observation this will create a 3D blob. The stacking is done in a lazy manner in order to reduce memory consumption. To achieve this, a LazyStack object is used in order to wrap the observations in the stack. For this reason, the ObservationStackingFilter must be the last filter in the inputs filters stack. ObservationUint8Filter - Converts a floating point observation into an unsigned int 8 bit observation. This is mostly useful for reducing memory consumption and is usually used for image observations. The filter will first spread the observation values over the range 0-255 and then discretize them into integer values. Reward Filters RewardClippingFilter - Clips the reward values into a given range. For example, in DQN, the Atari rewards are clipped into the range -1 and 1 in order to control the scale of the returns. RewardNormalizationFilter - Normalizes the reward values with a running mean and standard deviation of all the rewards seen so far. When working with multiple workers, the statistics used for the normalization operation are accumulated over all the workers. RewardRescaleFilter - Rescales the reward by a given factor. Rescaling the rewards of the environment has been observed to have a large effect (negative or positive) on the behavior of the learning process. Output Filters The output filters only process the actions. Action Filters AttentionDiscretization - Discretizes an AttentionActionSpace . The attention action space defines the actions as choosing sub-boxes in a given box. For example, consider an image of size 100x100, where the action is choosing a crop window of size 20x20 to attend to in the image. AttentionDiscretization allows discretizing the possible crop windows to choose into a finite number of options, and map a discrete action space into those crop windows. BoxDiscretization - Discretizes a continuous action space into a discrete action space, allowing the usage of agents such as DQN for continuous environments such as MuJoCo. Given the number of bins to discretize into, the original continuous action space is uniformly separated into the given number of bins, each mapped to a discrete action index. For example, if the original actions space is between -1 and 1 and 5 bins were selected, the new action space will consist of 5 actions mapped to -1, -0.5, 0, 0.5 and 1. BoxMasking - Masks part of the action space to enforce the agent to work in a defined space. For example, if the original action space is between -1 and 1, then this filter can be used in order to constrain the agent actions to the range 0 and 1 instead. This essentially masks the range -1 and 0 from the agent. PartialDiscreteActionSpaceMap - Partial map of two countable action spaces. For example, consider an environment with a MultiSelect action space (select multiple actions at the same time, such as jump and go right), with 8 actual MultiSelect actions. If we want the agent to be able to select only 5 of those actions by their index (0-4), we can map a discrete action space with 5 actions into the 5 selected MultiSelect actions. This will both allow the agent to use regular discrete actions, and mask 3 of the actions from the agent. FullDiscreteActionSpaceMap - Full map of two countable action spaces. This works in a similar way to the PartialDiscreteActionSpaceMap, but maps the entire source action space into the entire target action space, without masking any actions. LinearBoxToBoxMap - A linear mapping of two box action spaces. For example, if the action space of the environment consists of continuous actions between 0 and 1, and we want the agent to choose actions between -1 and 1, the LinearBoxToBoxMap can be used to map the range -1 and 1 to the range 0 and 1 in a linear way. This means that the action -1 will be mapped to 0, the action 1 will be mapped to 1, and the rest of the actions will be linearly mapped between those values.","title":"Filters"},{"location":"design/filters/index.html#filters","text":"Filters are a mechanism in Coach that allows doing pre-processing and post-processing of the internal agent information. There are two filter categories - Input filters - these are filters that process the information passed into the agent from the environment. This information includes the observation and the reward. Input filters therefore allow rescaling observations, normalizing rewards, stack observations, etc. Output filters - these are filters that process the information going out of the agent into the environment. This information includes the action the agent chooses to take. Output filters therefore allow conversion of actions from one space into another. For example, the agent can take N discrete actions, that will be mapped by the output filter onto N continuous actions. Filters can be stacked on top of each other in order to build complex processing flows of the inputs or outputs.","title":"Filters"},{"location":"design/filters/index.html#input-filters","text":"The input filters are separated into two categories - observation filters and reward filters .","title":"Input Filters"},{"location":"design/filters/index.html#observation-filters","text":"ObservationClippingFilter - Clips the observation values to a given range of values. For example, if the observation consists of measurements in an arbitrary range, and we want to control the minimum and maximum values of these observations, we can define a range and clip the values of the measurements. ObservationCropFilter - Crops the size of the observation to a given crop window. For example, in Atari, the observations are images with a shape of 210x160. Usually, we will want to crop the size of the observation to a square of 160x160 before rescaling them. ObservationMoveAxisFilter - Reorders the axes of the observation. This can be useful when the observation is an image, and we want to move the channel axis to be the last axis instead of the first axis. ObservationNormalizationFilter - Normalizes the observation values with a running mean and standard deviation of all the observations seen so far. The normalization is performed element-wise. Additionally, when working with multiple workers, the statistics used for the normalization operation are accumulated over all the workers. ObservationReductionBySubPartsNameFilter - Allows keeping only parts of the observation, by specifying their name. For example, the CARLA environment extracts multiple measurements that can be used by the agent, such as speed and location. If we want to only use the speed, it can be done using this filter. ObservationRescaleSizeByFactorFilter - Rescales an image observation by some factor. For example, the image size can be reduced by a factor of 2. ObservationRescaleToSizeFilter - Rescales an image observation to a given size. The target size does not necessarily keep the aspect ratio of the original observation. ObservationRGBToYFilter - Converts a color image observation specified using the RGB encoding into a grayscale image observation, by keeping only the luminance (Y) channel of the YUV encoding. This can be useful if the colors in the original image are not relevant for solving the task at hand. ObservationSqueezeFilter - Removes redundant axes from the observation, which are axes with a dimension of 1. ObservationStackingFilter - Stacks several observations on top of each other. For image observation this will create a 3D blob. The stacking is done in a lazy manner in order to reduce memory consumption. To achieve this, a LazyStack object is used in order to wrap the observations in the stack. For this reason, the ObservationStackingFilter must be the last filter in the inputs filters stack. ObservationUint8Filter - Converts a floating point observation into an unsigned int 8 bit observation. This is mostly useful for reducing memory consumption and is usually used for image observations. The filter will first spread the observation values over the range 0-255 and then discretize them into integer values.","title":"Observation Filters"},{"location":"design/filters/index.html#reward-filters","text":"RewardClippingFilter - Clips the reward values into a given range. For example, in DQN, the Atari rewards are clipped into the range -1 and 1 in order to control the scale of the returns. RewardNormalizationFilter - Normalizes the reward values with a running mean and standard deviation of all the rewards seen so far. When working with multiple workers, the statistics used for the normalization operation are accumulated over all the workers. RewardRescaleFilter - Rescales the reward by a given factor. Rescaling the rewards of the environment has been observed to have a large effect (negative or positive) on the behavior of the learning process.","title":"Reward Filters"},{"location":"design/filters/index.html#output-filters","text":"The output filters only process the actions.","title":"Output Filters"},{"location":"design/filters/index.html#action-filters","text":"AttentionDiscretization - Discretizes an AttentionActionSpace . The attention action space defines the actions as choosing sub-boxes in a given box. For example, consider an image of size 100x100, where the action is choosing a crop window of size 20x20 to attend to in the image. AttentionDiscretization allows discretizing the possible crop windows to choose into a finite number of options, and map a discrete action space into those crop windows. BoxDiscretization - Discretizes a continuous action space into a discrete action space, allowing the usage of agents such as DQN for continuous environments such as MuJoCo. Given the number of bins to discretize into, the original continuous action space is uniformly separated into the given number of bins, each mapped to a discrete action index. For example, if the original actions space is between -1 and 1 and 5 bins were selected, the new action space will consist of 5 actions mapped to -1, -0.5, 0, 0.5 and 1. BoxMasking - Masks part of the action space to enforce the agent to work in a defined space. For example, if the original action space is between -1 and 1, then this filter can be used in order to constrain the agent actions to the range 0 and 1 instead. This essentially masks the range -1 and 0 from the agent. PartialDiscreteActionSpaceMap - Partial map of two countable action spaces. For example, consider an environment with a MultiSelect action space (select multiple actions at the same time, such as jump and go right), with 8 actual MultiSelect actions. If we want the agent to be able to select only 5 of those actions by their index (0-4), we can map a discrete action space with 5 actions into the 5 selected MultiSelect actions. This will both allow the agent to use regular discrete actions, and mask 3 of the actions from the agent. FullDiscreteActionSpaceMap - Full map of two countable action spaces. This works in a similar way to the PartialDiscreteActionSpaceMap, but maps the entire source action space into the entire target action space, without masking any actions. LinearBoxToBoxMap - A linear mapping of two box action spaces. For example, if the action space of the environment consists of continuous actions between 0 and 1, and we want the agent to choose actions between -1 and 1, the LinearBoxToBoxMap can be used to map the range -1 and 1 to the range 0 and 1 in a linear way. This means that the action -1 will be mapped to 0, the action 1 will be mapped to 1, and the rest of the actions will be linearly mapped between those values.","title":"Action Filters"},{"location":"design/network/index.html","text":"Network Design Each agent has at least one neural network, used as the function approximator, for choosing the actions. The network is designed in a modular way to allow reusability in different agents. It is separated into three main parts: Input Embedders - This is the first stage of the network, meant to convert the input into a feature vector representation. It is possible to combine several instances of any of the supported embedders, in order to allow varied combinations of inputs. There are two main types of input embedders: Image embedder - Convolutional neural network. Vector embedder - Multi-layer perceptron. Middlewares - The middleware gets the output of the input embedder, and processes it into a different representation domain, before sending it through the output head. The goal of the middleware is to enable processing the combined outputs of several input embedders, and pass them through some extra processing. This, for instance, might include an LSTM or just a plain simple FC layer. Output Heads - The output head is used in order to predict the values required from the network. These might include action-values, state-values or a policy. As with the input embedders, it is possible to use several output heads in the same network. For example, the Actor Critic agent combines two heads - a policy head and a state-value head. In addition, the output heads defines the loss function according to the head type. \u200b Keeping Network Copies in Sync Most of the reinforcement learning agents include more than one copy of the neural network. These copies serve as counterparts of the main network which are updated in different rates, and are often synchronized either locally or between parallel workers. For easier synchronization of those copies, a wrapper around these copies exposes a simplified API, which allows hiding these complexities from the agent.","title":"Network"},{"location":"design/network/index.html#network-design","text":"Each agent has at least one neural network, used as the function approximator, for choosing the actions. The network is designed in a modular way to allow reusability in different agents. It is separated into three main parts: Input Embedders - This is the first stage of the network, meant to convert the input into a feature vector representation. It is possible to combine several instances of any of the supported embedders, in order to allow varied combinations of inputs. There are two main types of input embedders: Image embedder - Convolutional neural network. Vector embedder - Multi-layer perceptron. Middlewares - The middleware gets the output of the input embedder, and processes it into a different representation domain, before sending it through the output head. The goal of the middleware is to enable processing the combined outputs of several input embedders, and pass them through some extra processing. This, for instance, might include an LSTM or just a plain simple FC layer. Output Heads - The output head is used in order to predict the values required from the network. These might include action-values, state-values or a policy. As with the input embedders, it is possible to use several output heads in the same network. For example, the Actor Critic agent combines two heads - a policy head and a state-value head. In addition, the output heads defines the loss function according to the head type. \u200b","title":"Network Design"},{"location":"design/network/index.html#keeping-network-copies-in-sync","text":"Most of the reinforcement learning agents include more than one copy of the neural network. These copies serve as counterparts of the main network which are updated in different rates, and are often synchronized either locally or between parallel workers. For easier synchronization of those copies, a wrapper around these copies exposes a simplified API, which allows hiding these complexities from the agent.","title":"Keeping Network Copies in Sync"}]}